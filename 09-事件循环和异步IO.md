### 什么是事件循环
+ 事件循环可以理解成我们编写的JavaScript和浏览器或者Node之间的一个桥梁
+ 浏览器的事件循环是一个我们编写的JavaScript代码和浏览器API调用(setTimeout/AJAX/监听事件等)的一个桥梁, 桥梁之间是通过回调函数来进行沟通的
+ Node的事件循环时我们编写的JavaScript代码和系统调用(file system, network等)之间的一个桥梁, 桥梁之间是通过回调函数来进行沟通的

### 进程和线程
+ 进程和线程是操作系统中的两个概念
  - 进程(process): 计算机已经运行的程序
  - 线程(thread): 操作系统能够运行运算调度的最小单位
+ 直观来解释就是
  - 进程: 启动一个应用程序, 就会默认启动一个进程(也有可能是多进程, 比如浏览器, 浏览器中的一个页面就是一个进程)\
  - 线程: 每一个进程中, 都会启动一个线程用来执行程序中的代码, 这个线程被称为主线程
  - 所以我们可以称进程是线程的容器
+ 用一个形象的例子来解释:
  - 操作系统类似于一个工厂
  - 工厂中有很多个车间, 这些车间就是进程
  - 每一个车间可能有一个以上的工人在工作, 这些工人就是线程

### 多进程多线程开发
+ 操作系统是如何做到同时让多个进程同时工作呢?
  - 这是由于CPU的运算速度非常快, 它可以快速地在多个进程之间迅速地切换
  - 当我们的进程中的线程获取到时间片时, 就可以快速执行代码
  - 对于用户来说是感觉不到这种快速的切换的

### 浏览器和JavaScript
+ 我们经常会说JavaScript是单线程的, 但是JavaScript的线程有自己的容器进程: 也就是浏览器或者Node
+ 浏览器是一个进程, 而且浏览器中可以有很多的线程
  - 多数浏览器都是多进程的, 当打开一个tab页面的时候就会开启一个新的进程, 这是为了防止一个页面卡死的情况下造成所有页面无法响应, 整个浏览器需要强制退出的问题
  - 浏览器中的每一个进程又有很多的线程, 其中包括执行JavaScript代码的线程
+ 但是JavaScript的代码执行是在一个单独的线程中执行的
  - 这就意味着JavaScript的代码, 在同一个时刻只能做一件事情
  - 如果这件事是非常耗时的, 就意味着当前的线程阻塞

### JavaScript代码的执行过程
+ 实际上浏览器或者Node执行JavaScript的异步代码时, 会将异步代码放到事件队列中, 然后再合适的时机, 将其回调函数放到函数调用栈中执行

### 宏任务和微任务
+ 事件循环中并非只维护着一个队列, 事实上有两个队列
  - 宏任务队列 (macrotask queue): ajax, setTimeout, setInterval, DOM监听事件, UI Rendering等
  - 微任务队列 (microtask queue): Promise的then回调, Mutation Observer API, queueMicrotask()等
  - 注意async await是Promise的一个语法糖
    + 我们可以将await关键字后面执行的代码, 看作是包裹在(resolve, reject) => (函数执行) 中的代码
    + await的下一条语句, 可以看作是then(res => (函数执行))中的代码
+ 事件循环对两个队列的优先级
  - 1. main script中的代码优先执行(编写的顶层script代码)
  - 2. 在执行任何一个宏任务之前(不是队列, 是一个宏任务), 都会先查看微任务队列中是否有微任务需要执行
    + 也就是说宏任务执行之前, 必须保证微任务队列是空的
    + 如果微任务队列不为孔, 那么就优先执行微任务队列中的任务(回调)

### Node的架构分析
+ 浏览器中的EventLoop是根据HTML5定义的规范来实现的, 不同的浏览器可能会有不同的实现, 而Node中是由libuv来实现的
+ libuv中主要维护了一个EventLoop和worker threads(线程池)
+ EventLoop负责调用系统的一些其他操作: 文件的IO, Network, child-processes等
+ libuv是一个多平台的专注于异步IO的库, 它最初是为了Node开发的, 但是现在也被使用在Luvit, Julia, pyuv等其他地方

### 阻塞IO和非阻塞IO
+ 如果我们希望在程序中对一个文件进行操作, 那么我们就需要打开这个文件: 通过文件描述符
  - JavaScript是否可以对一个文件进行操作呢?
  - 事实上我们任何程序中的文件操作都是需要进行系统调用(操作系统的文件系统)来实现的
  - 所以对文件的操作, 是一个操作系统的IO操作(input, output)
+ 操作系统为我们提供了阻塞式调用和非阻塞式调用:
  - 阻塞式调用: 调用结果返回之前, 当前线程处于阻塞态(阻塞态式CPU是不会分配时间片的), 调用线程只有在得到调用结果后才会继续执行下去
  - 非阻塞式调用: 调用执行之后, 当前线程式不会停止执行的, 只会过一段时间来检查一下有没有结果返回
+ 所以我们开发中的很多耗时的操作, 都可以基于非阻塞式调用
  - 比如网络请求本身使用了Socket通讯, 而Socket本身提供了select模型, 可以进行非阻塞式工作
  - 比如文件读写的IO操作, 我们可以使用操作系统提供的基于事件的回调机制

### 非阻塞IO的问题
+ 非阻塞IO也会存在一定的问题: 在调用结果返回之前, 我们斌没有获取到需要读取的结果
  - 那么就意味着为了可以知道是否读取到完整的数据, 我们需要频繁地去确定读取到的数据是否是完整地
  - 这个过程称为轮询操作
+ 这个轮询工作是由谁来完成的呢?
  - 如果我们地主线程频繁地去进行轮询的工作, 那么必然会大大降低性能
  - 并且开发中我们可能不只是一个文件的读写, 可能是多个文件
  - 而且可能是多个功能: 网络的IO, 数据库的IO, 子进程的调用
+ libuv提供了一个线程池(Thread Pool)
  - 线程池会负责所有相关的操作, 摈弃会通过轮询等方式等待结果
  - 当获取到结果的时候, 就可以将对应的回调放到事件循环(某一个事件队列)中
  - 事件循环就可以负责接管后续的回调工作, 告知JavaScript应用程序执行对应的回调函数

### 阻塞和非阻塞, 同步和异步的区别
+ 阻塞和非阻塞是对于被调用者来说的
  - 在我们这里就是系统调用, 操作系统为我们提供了阻塞调用和非阻塞调用
+ 同步和异步是对于调用者说的
  - 在我们这里就是自己编写的程序
  - 如果我们在发起调用之后, 不会进行其他任何操作, 只是等待结果, 这个过程就称为同步调用
  - 如果我们在发起调用之后, 并不会等待结果, 而是继续完成下面的工作, 等到调用结果出来之后再去执行, 这个过程就称为异步调用
+ Libuv采用的就是非阻塞异步IO的调用方式

### Node事件循环的阶段
+ 事件循环就像是一个桥梁, 是链接应用程序的JavaScript和系统调用之间的通道
  - 无论是文件IO, 数据库, 网络IO, 定时器, 子进程, 再完成对应的操作之后, 都会将对应的结果和回调函数放到事件循环(任务队列)中
  - 事件循环会不断地从任务队列中取出对应的事件(回调函数)来执行
+ 但是一次完整的事件循环Tic分成很多个阶段(每一个阶段执行相对应的回调函数)
  - 定时器(Timer): 本阶段执行已经被setTimeout() 和 setInterval() 的调度回调函数
  - 待定回调(Pending Callback): 对某些系统操作(比如TCP错误类型)执行回调, 比如TCP连接时接收到ECONNREFUSED
  - idle, prepare: 仅系统内部使用
  - 轮询(Poll): 检查新的I/O事件; 执行与I/O相关的回调 (在这个阶段会又一个小停留, 这是为了用户的IO操作可以尽可能早的获得结果)
  - 检测: setImmediate() 回调函数在这里执行
  - 关闭的回调函数: 一些关闭的回调函数. 比如: socket.on('close', () => {})

###   Node的微任务和宏任务
+ 我们会发现一次事件循环Tick来说, Node的事件循环比浏览器的事件循环更加复杂, 也分为微任务和宏任务
  - 宏任务(macrotask): setTimeout, setInterval, IO事件, setImmediate, close事件
  - 微任务(microtask): Promise的then回调, process.nextTick, queueMicrotask
+ 但是, Node中的事件循环不只是微任务和宏任务
  - 微任务队列又分为
    + next tick queue: process.nextTick
    + other queue : Promise的then回调, queueMicrotask
  - 宏任务又分为
    + timer queue: setTimeout, setInterval
    + poll queue: IO事件
    + check queue: setImmediate
    + close queue: close事件